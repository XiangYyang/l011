// Generate FFI module
// SPDX-License-Identifier: GPL-3.0
// Copyright (c) XiangYang, all rights reserved.

//! **FFI module generator**
//!
//! This module generate code for FFI module.
//! That includes `@cImport` and `@cDefine` statements,
//! and that reduces the effort required for manual maintenance.

const std = @import("std");

const PredefineMacro = struct {
    name: []const u8,
    value: ?[]const u8,
};

const PredefineMacroParseError = error{
    NotPredefineStatement,
    MacroDefineIsInvaild,
};

pub fn main() !void {
    var arena_state = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena_state.deinit();

    const alloc = arena_state.allocator();

    const args = try std.process.argsAlloc(alloc);

    if (args.len <= 2) {
        fatal("[FATAL] wrong number of arguments", .{});
    }

    const c_flags_cnt = try std.fmt.parseInt(usize, args[2], 10);

    const c_flags = args[3..(3 + c_flags_cnt)];
    const output_file_path = args[1];

    var output_file = std.fs.cwd().createFile(output_file_path, .{}) catch |err| {
        fatal("[FATAL] unable to open '{s}': {s}", .{ output_file_path, @errorName(err) });
    };
    defer output_file.close();

    // codegen: document comment
    try output_file.writeAll(
        \\//! # cImport FFI
        \\//!
        \\//! This module was auto-generated by `chead.zig`.
        \\//! It provides FFI wrapper functions.
        \\//!
        \\//! ## pre-define macro
        \\//!
        \\
        \\// <codegen>
        \\
        \\
    );

    // get all c_flags
    var c_flag_arg = std.ArrayList(PredefineMacro).init(alloc);
    defer c_flag_arg.deinit();

    for (c_flags) |arg| {
        const parsed_flag = if (parse_predefine(arg)) |val| val else |err| switch (err) {
            PredefineMacroParseError.NotPredefineStatement => {
                // ignore not_found error
                continue;
            },
            else => {
                fatal("[FATAL] parse flag error: {s}", .{@errorName(err)});
            },
        };

        try c_flag_arg.append(parsed_flag);

        const doc_str = try std.fmt.allocPrint(alloc, "//! * `{s}`\n", .{arg});
        defer alloc.free(doc_str);

        try output_file.writeAll(doc_str);
    }

    // codegen: import_header function
    try output_file.writeAll(
        \\/// import c header file
        \\pub fn import_header(comptime file: []const u8) type {
        \\    return @cImport({
        \\
    );

    // codegen: import_header function body
    for (c_flag_arg.items) |flag| {
        if (flag.value) |def_val| {
            const def_str = try std.fmt.allocPrint(
                alloc,
                "        @cDefine(\"{s}\", \"{s}\");\n",
                .{ flag.name, def_val },
            );
            defer alloc.free(def_str);

            try output_file.writeAll(def_str);
        } else {
            const def_str = try std.fmt.allocPrint(
                alloc,
                "        @cDefine(\"{s}\", {{}});\n",
                .{flag.name},
            );
            defer alloc.free(def_str);

            try output_file.writeAll(def_str);
        }
    }

    // codegen: import_header right bracket
    try output_file.writeAll(
        \\        @cInclude(file);
        \\    });
        \\}
        \\
        \\// </codegen>
        \\
    );

    return std.process.cleanExit();
}

fn parse_predefine(flag: []const u8) PredefineMacroParseError!PredefineMacro {
    if (!is_predefine_arg(flag)) {
        return PredefineMacroParseError.NotPredefineStatement;
    }

    var idx: u32 = 0;
    var obj = PredefineMacro{ .name = "", .value = null };
    var parsed_values = std.mem.split(u8, flag, "=");
    while (parsed_values.next()) |parsed_value| {
        switch (idx) {
            0 => obj.name = parsed_value[2..],
            1 => obj.value = parsed_value,
            else => return PredefineMacroParseError.MacroDefineIsInvaild,
        }
        idx += 1;
    }

    return obj;
}

fn is_predefine_arg(flag: []const u8) bool {
    return std.ascii.startsWithIgnoreCase(flag, "-D");
}

fn fatal(comptime format: []const u8, args: anytype) noreturn {
    std.debug.print(format, args);
    std.process.exit(1);
}
